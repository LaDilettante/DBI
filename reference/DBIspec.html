<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>DBI specification — DBIspec • DBI</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">


<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>

<!-- mathjax -->
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">DBI</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>DBI specification</h1>
    </div>

    
    <p>The <span class="pkg">DBI</span> package defines the generic DataBase Interface for R.
The connection to individual DBMS is made by packages that import <span class="pkg">DBI</span>
(so-called <em>DBI backends</em>).
This document formalizes the behavior expected by the functions declared in
<span class="pkg">DBI</span> and implemented by the individal backends.</p>

    <p>To ensure maximum portability and exchangeability, and to reduce the effort
for implementing a new DBI backend, the <span class="pkg">DBItest</span> package defines
a comprehensive set of test cases that test conformance to the DBI
specification.
In fact, this document is derived from comments in the test definitions of
the <span class="pkg">DBItest</span> package.
This ensures that an extension or update to the tests will be reflected in
this document.</p>
    

        
    <h2 class="hasAnchor" id="getting-started"><a class="anchor" href="#getting-started"></a>Getting started</h2>

    <p></p>
    <p>A DBI backend is an R package,
which should import the <span class="pkg">DBI</span>
and <span class="pkg">methods</span>
packages.
For better or worse, the names of many existing backends start with
&#8216;R&#8217;, e.g., <span class="pkg">RSQLite</span>, <span class="pkg">RMySQL</span>, <span class="pkg">RSQLServer</span>; it is up
to the package author to adopt this convention or not.</p>
    
    <h2 class="hasAnchor" id="driver"><a class="anchor" href="#driver"></a>Driver</h2>

    <p></p>
    <p><h3>Construction</h3></p>
    <p>The backend must support creation of an instance of this driver class
with a <dfn>constructor function</dfn>.
By default, its name is the package name without the leading &#8216;R&#8217;
(if it exists), e.g., <code>SQLite</code> for the <span class="pkg">RSQLite</span> package.
For the automated tests, the constructor name can be tweaked using the
<code>constructor_name</code> tweak.</p>
    <p>The constructor must be exported, and
it must be a function
that is callable without arguments.
For the automated tests, unless the
<code>constructor_relax_args</code> tweak is set to <code>TRUE</code>,
an empty argument list is expected.
Otherwise, an argument list where all arguments have default values
is also accepted.</p>
    <p>Each DBI backend implements a <dfn>driver class</dfn>,
which must be an S4 class and inherit from the <code>DBIDriver</code> class.
This section describes the construction of, and the methods defined for,
this driver class.</p>
    
    <h2 class="hasAnchor" id="transactions"><a class="anchor" href="#transactions"></a>Transactions</h2>

    <p></p>
    <p><h3><code>dbBegin(&quot;DBIConnection&quot;)</code> and <code>dbCommit(&quot;DBIConnection&quot;)</code></h3></p>
    <p>Transactions are available in DBI, but actual support may vary between backends.
A transaction is initiated by a call to <code>DBI::dbBegin()</code>
and committed by a call to <code>DBI::dbCommit()</code>.
Both generics expect an object of class <code><a href='DBIConnection-class.html'>DBIConnection</a></code>
and return <code>TRUE</code> (invisibly) upon success.</p>
    <p>The implementations are expected to raise an error in case of failure,
but this is difficult to test in an automated way.
In any way, both generics should throw an error with a closed connection.
In addition, a call to <code>DBI::dbCommit()</code> without
a call to <code>DBI::dbBegin()</code> should raise an error.
Nested transactions are not supported by DBI,
an attempt to call <code>DBI::dbBegin()</code> twice
should yield an error.</p>
    <p>Data written in a transaction must persist after the transaction is committed.
For example, a table that is missing when the transaction is started
but is created
and populated during the transaction
must exist and contain the data added there
both during
and after the transaction.</p>
    <p>The behavior is not specified if other arguments are passed to these
functions. In particular, <span class="pkg">RSQLite</span> issues named transactions
if the <code>name</code> argument is set.</p>
    <p>The transaction isolation level is not specified by DBI.</p>
    
    <h2 class="hasAnchor" id="specification"><a class="anchor" href="#specification"></a>Specification</h2>

    <p></p>
    <p>The backend can override the <code>DBI::dbDataType()</code> generic
for its driver class.</p>
    <p>This generic expects an arbitrary object as second argument.
To query the values returned by the default implementation,
run <code>example(dbDataType, package = &quot;DBI&quot;)</code>.
If the backend needs to override this generic,
it must accept all basic R data types as its second argument, namely
logical,
integer,
numeric,
character,
dates (see Dates),
date-time (see DateTimeClasses),
and difftime.
It also must accept lists of raw vectors
and map them to the BLOB (binary large object) data type,
unless the <code>omit_blob_tests</code> tweak is set to <code>TRUE</code>.
As-is objects (i.e., wrapped by <code>I()</code>) must be
supported and return the same results as their unwrapped counterparts.
The SQL data type for factor
and ordered is the same as for character.
The behavior for other object types is not specified.</p>
    <p>All data types returned by <code>dbDataType()</code> are usable in an SQL statement
of the form
<code>&quot;CREATE TABLE test (a ...)&quot;</code>.</p>
    <p>DBI specifies only the return type for <code>dbConnect()</code>.</p>
    <p>A warning is issued when releasing a connection without calling
<code>dbDisconnect()</code>,
or when calling <code>dbDisconnect()</code> on an already disconnected connection.</p>
    <p>No warnings occur under normal conditions.
The DBIResult object returned by <code>dbSendQuery()</code> must be valid, i.e.,
<code><a href='dbIsValid.html'>dbIsValid()</a></code> returns <code>TRUE</code>.
When done, the DBIResult object must be cleared with a call to
<code>DBI::dbClearResult()</code>.
Failure to clear the result set leads to a warning
when the connection is closed.</p>
    <p>If the backend supports only one open result set per connection,
issuing a second query invalidates an already open result set
and raises a warning.
The newly opened result set is valid
and must be cleared with <code>dbClearResult()</code>.</p>
    <p>Fetching multi-row queries with one
or more columns be default returns the entire result.
Multi-row queries can also be fetched progressively
by passing a whole number (integer
or numeric)
as the <code>n</code> argument.
A value of Inf for the <code>n</code> argument is supported
and also returns the full result.
If more rows than available are fetched, the result is returned in full
without warning.
If zero rows are fetched, the columns of the data frame are still fully
typed.
Fetching fewer rows than available is permitted,
no warning is issued when clearing the result set.</p>
    <p>The column types of the returned data frame depend on the data returned:
<ul>
<li> integer for integer values between -2^31 and 2^31 - 1
</li>
<li> numeric for numbers with a fractional component
</li>
<li> logical for Boolean values (some backends may return an integer)
</li>
<li> character for text
</li>
<li> lists of raw for blobs (with <code>NULL</code> entries for SQL NULL values)
</li>
<li> coercible using <code>as.Date()</code> for dates
(also applies to the return value of the SQL function <code>current_date</code>)
</li>
<li> coercible using <code><a href='http://www.rdocumentation.org/packages/hms/topics/hms'>hms::as.hms()</a></code> for times
(also applies to the return value of the SQL function <code>current_time</code>)
</li>
<li> coercible using <code>as.POSIXct()</code> for timestamps
(also applies to the return value of the SQL function <code>current_timestamp</code>)
</li>
<li> NA for SQL <code>NULL</code> values
</li>
</ul></p>
    <p>If dates and timestamps are supported by the backend, the following R types are
used:
<ul>
<li> Date for dates
(also applies to the return value of the SQL function <code>current_date</code>)
</li>
<li> POSIXct for timestamps
(also applies to the return value of the SQL function <code>current_timestamp</code>)
</li>
</ul></p>
    <p>R has no built-in type with lossless support for the full range of 64-bit
or larger integers. Here, the following rules apply:
<ul>
<li> Values are returned as numeric
</li>
<li> Conversion to character always returns a lossless decimal representation
of the data
</li>
</ul></p>
    <p><code>dbClearResult()</code> frees all resources associated with retrieving
the result of a query or update operation.
The DBI backend can expect a call to <code>dbClearResult()</code> for each
<code>DBI::dbSendQuery()</code> or <code>DBI::dbSendStatement()</code> call.</p>
    <p>Fetching multi-row queries with one
or more columns be default returns the entire result.
A value of Inf for the <code>n</code> argument is supported
and also returns the full result.
If more rows than available are fetched, the result is returned in full
without warning.
If zero rows are fetched, the columns of the data frame are still fully
typed.
Fetching fewer rows than available is permitted,
no warning is issued.</p>
    <p>No warnings occur under normal conditions.
The DBIResult object returned by <code>dbSendStatement()</code> must be valid, i.e.,
<code><a href='dbIsValid.html'>dbIsValid()</a></code> returns <code>TRUE</code>.
When done, the DBIResult object must be cleared with a call to
<code>DBI::dbClearResult()</code>.
Failure to clear the result set leads to a warning
when the connection is closed.
If the backend supports only one open result set per connection,
issuing a second query invalidates an already open result set
and raises a warning.
The newly opened result set is valid
and must be cleared with <code>dbClearResult()</code>.</p>
    <p>No warnings occur under normal conditions.</p>
    <p>The returned expression can be used in a <code>SELECT ...</code> query,
and for any scalar character <code>x</code> the value of
<code>dbGetQuery(paste0(&quot;SELECT &quot;, dbQuoteString(x)))[[1]]</code>
must be identical to <code>x</code>,
even if <code>x</code> contains
spaces,
quotes (single
or double),
backticks,
or newlines
(in any combination)
or is itself the result of a <code>dbQuoteString()</code> call coerced back to
character (even repeatedly).
If <code>x</code> is <code>NA</code>, the result must merely satisfy <code>is.na()</code>.
The strings <code>&quot;NA&quot;</code> or <code>&quot;NULL&quot;</code> are not treated specially.</p>
    <p><code>NA</code> should be translated to an unquoted SQL <code>NULL</code>,
so that the query <code>SELECT * FROM (SELECT 1) a WHERE ... IS NULL</code>
returns one row.</p>
    <p>Calling <code>DBI::dbGetQuery()</code> for a query of the format <code>SELECT 1 AS ...</code>
returns a data frame with the identifier, unquoted, as column name.
Quoted identifiers can be used as table and column names in SQL queries,
in particular in queries like <code>SELECT 1 AS ...</code>
and <code>SELECT * FROM (SELECT 1) ...</code>.
This is also true for column names that are empty strings
or contain special characters such as a space,
a dot,
a comma,
or quotes used to mark strings
or identifiers,
if the database supports this.
In any case, checking the validity of the identifier
should be performed only when executing a query,
and not by <code>dbQuoteIdentifier()</code>.</p>
    <p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
<ul>
<li> If an unquoted table name as string: <code>dbReadTable()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name, ...)</code>
so that all optional arguments are passed along
</li>
<li> If the result of a call to <code><a href='dbQuoteIdentifier.html'>dbQuoteIdentifier()</a></code>: no more quoting is done
</li>
</ul></p>
    <p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
<ul>
<li> If an unquoted table name as string: <code>dbWriteTable()</code> will do the quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name, ...)</code>
so that all optional arguments are passed along
</li>
<li> If the result of a call to <code><a href='dbQuoteIdentifier.html'>dbQuoteIdentifier()</a></code>: no more quoting is done
</li>
</ul></p>
    <p>If the <code>overwrite</code> argument is <code>TRUE</code>, an existing table of the same name
will be overwritten.
This argument doesn&#39;t change behavior if the table does not exist yet.</p>
    <p>If the <code>append</code> argument is <code>TRUE</code>, the rows in an existing table are
preserved, and the new data are appended.
If the table doesn&#39;t exist yet, it is created.</p>
    <p>If the <code>temporary</code> argument is <code>TRUE</code>, the table is not available in a
second connection and is gone after reconnecting.
Not all backends support this argument.
A regular, non-temporary table is visible in a second connection
and after reconnecting to the database.</p>
    <p>SQL keywords can be used freely in table names, column names, and data.
Quotes, commas, and spaces can also be used in the data,
and, if the database supports non-syntactic identifiers,
also for table names and column names.</p>
    <p>The following data types must be supported at least,
and be read identically with <code><a href='dbReadTable.html'>dbReadTable()</a></code>:
<ul>
<li> integer
</li>
<li> numeric
(also with <code>Inf</code> and <code>NaN</code> values,
the latter are translated to <code>NA</code>)
</li>
<li> logical
</li>
<li> <code>NA</code> as NULL
</li>
<li> 64-bit values (using <code>&quot;bigint&quot;</code> as field type)
</li>
<li> character (in both UTF-8
and native encodings)
</li>
<li> factor (returned as character)
</li>
<li> list of raw
(if supported by the database)
</li>
<li> date
(if supported by the database;
returned as integers with class <code>Date</code>)
</li>
<li> time
(if supported by the database;
returned as objects that inherit from <code>difftime</code>)
</li>
<li> timestamp
(if supported by the database;
with time zone support)
</li>
</ul></p>
    <p>The interpretation of <a href='rownames.html'>rownames</a> depends on the <code>row.names</code> argument,
see <code>DBI::sqlRownamesToColumn()</code> for details:
<ul>
<li> If <code>FALSE</code>, row names are ignored.
</li>
<li> If <code>TRUE</code>, row names are converted to a column named &quot;row_names&quot;,
even if the input data frame only has natural row names from 1 to <code>nrow(...)</code>.
</li>
<li> If <code>NA</code>, a column named &quot;row_names&quot; is created if the data has custom row names,
no extra column is created in the case of natural row names.
</li>
<li> If a string, this specifies the name of the column in the remote table
that contains the row names,
even if the input data frame only has natural row names.
</li>
</ul></p>
    <p>TBD (schema support).</p>
    <p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
<ul>
<li> If an unquoted table name as string: <code>dbExistsTable()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name, ...)</code>
so that all optional arguments are passed along
</li>
<li> If the result of a call to <code><a href='dbQuoteIdentifier.html'>dbQuoteIdentifier()</a></code>: no more quoting is done
</li>
</ul></p>
    <p>For all tables listed by <code><a href='dbListTables.html'>dbListTables()</a></code>, <code>dbExistsTable()</code> returns <code>TRUE</code>.</p>
    <p>A table removed by <code>dbRemoveTable()</code> doesn&#39;t appear in the list of tables
returned by <code><a href='dbListTables.html'>dbListTables()</a></code>,
and <code><a href='dbExistsTable.html'>dbExistsTable()</a></code> returns <code>FALSE</code>.
The removal propagates immediately to other connections to the same database.
This function can also be used to remove a temporary table.</p>
    <p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
<ul>
<li> If an unquoted table name as string: <code>dbRemoveTable()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name, ...)</code>
so that all optional arguments are passed along
</li>
<li> If the result of a call to <code><a href='dbQuoteIdentifier.html'>dbQuoteIdentifier()</a></code>: no more quoting is done
</li>
</ul></p>
    <p>The completion status for a query is only guaranteed to be set to
<code>FALSE</code> after attempting to fetch past the end of the entire result.
Therefore, for a query with an empty result set,
the initial return value is unspecified,
but the result value is <code>TRUE</code> after trying to fetch only one row.
Similarly, for a query with a result set of length n,
the return value is unspecified after fetching n rows,
but the result value is <code>TRUE</code> after trying to fetch only one more
row.</p>
    <p><span class="pkg">DBI</span> clients execute parametrized statements as follows:
<ol>
<li> Call <code>DBI::dbSendQuery()</code> or <code>DBI::dbSendStatement()</code> with a query or statement
that contains placeholders,
store the returned DBI::DBIResult object in a variable.
Mixing placeholders (in particular, named and unnamed ones) is not
recommended.
It is good practice to register a call to <code>DBI::dbClearResult()</code> via
<code>on.exit()</code> right after calling <code>dbSendQuery()</code> or <code>dbSendStatement()</code>
(see the last enumeration item).
</li>
<li> Construct a list with parameters
that specify actual values for the placeholders.
The list must be named or unnamed,
depending on the kind of placeholders used.
Named values are matched to named parameters, unnamed values
are matched by position in the list of parameters.
All elements in this list must have the same lengths and contain values
supported by the backend; a data.frame is internally stored as such
a list.
The parameter list is passed to a call to <code>dbBind()</code> on the <code>DBIResult</code>
object.
</li>
<li> Retrieve the data or the number of affected rows from the <code>DBIResult</code> object.
<ul>
<li> For queries issued by <code>dbSendQuery()</code>,
call <code>DBI::dbFetch()</code>.
</li>
<li> For statements issued by <code>dbSendStatements()</code>,
call <code>DBI::dbGetRowsAffected()</code>.
(Execution begins immediately after the <code>dbBind()</code> call,
the statement is processed entirely before the function returns.)
</li>
</ul></p>
    <p></li>
<li> Repeat 2. and 3. as necessary.
</li>
<li> Close the result set via <code>DBI::dbClearResult()</code>.
</li>
</ol></p>
    <p>The elements of the <code>params</code> argument do not need to be scalars,
vectors of arbitrary length
(including length 0)
are supported.
For queries, calling <code>dbFetch()</code> binding such parameters returns
concatenated results, equivalent to binding and fetching for each set
of values and connecting via <code>rbind()</code>.
For data manipulation statements, <code>dbGetRowsAffected()</code> returns the
total number of rows affected if binding non-scalar parameters.
<code>dbBind()</code> also accepts repeated calls on the same result set
for both queries
and data manipulation statements,
even if no results are fetched between calls to <code>dbBind()</code>.</p>
    <p>At least the following data types are accepted:
<ul>
<li> integer
</li>
<li> numeric
</li>
<li> logical for Boolean values (some backends may return an integer)
</li>
<li> NA
</li>
<li> character
</li>
<li> Date
</li>
<li> POSIXct timestamps
</li>
<li> POSIXlt timestamps
</li>
<li> lists of raw for blobs (with <code>NULL</code> entries for SQL NULL values)
</li>
</ul></p>
    
    <h2 class="hasAnchor" id="additional-arguments"><a class="anchor" href="#additional-arguments"></a>Additional arguments</h2>

    <p></p>
    <p>The following arguments are not part of the <code>dbReadTable()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
<ul>
<li> <code>row.names</code>
</li>
<li> <code>check.names</code>
</li>
</ul></p>
    <p>They must be provided as named arguments.
See the &quot;Value&quot; section for details on their usage.</p>
    <p>The following arguments are not part of the <code>dbWriteTable()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
<ul>
<li> <code>row.names</code> (default: <code>NA</code>)
</li>
<li> <code>overwrite</code> (default: <code>FALSE</code>)
</li>
<li> <code>append</code> (default: <code>FALSE</code>)
</li>
<li> <code>field.types</code> (default: <code>NULL</code>)
</li>
<li> <code>temporary</code> (default: <code>FALSE</code>)
</li>
</ul></p>
    <p>They must be provided as named arguments.
See the &quot;Specification&quot; and &quot;Value&quot; sections for details on their usage.</p>
    <p>TBD (schema support).</p>
    <p>TBD: Schema support.</p>
    <p>They must be provided as named arguments.
See the &quot;Specification&quot; section for details on their usage.</p>
    <p>TBD: Schema support.</p>
    <p>They must be provided as named arguments.
See the &quot;Specification&quot; section for details on their usage.</p>
    

  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      
      <li><a href="#getting-started">Getting started</a></li>

      <li><a href="#driver">Driver</a></li>

      <li><a href="#transactions">Transactions</a></li>

      <li><a href="#specification">Specification</a></li>

      <li><a href="#additional-arguments">Additional arguments</a></li>
          </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by R Special Interest Group on Databases (R-SIG-DB), <a href='http://hadley.nz'>Hadley Wickham</a>, Kirill Müller.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  </body>
</html>
